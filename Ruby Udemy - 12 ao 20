Aula 12:

STDIN -> Entrada de dados
gets -> get (pegar) s (string)
\n -> quebra de linha
.inspect -> inspeciona o que esta na variavel

Condições
if (elsif, else)
	if condição
		codigo
	elsif condição
		codigo
	else
		codigo
	end

unless (else - não aceita elsif, é um ou ou outro) (a menos q)
	unless condição
		codigo
	else
		código
	end

case (when - geralmente usado em menu)
	case a
	when 1
		código
	when 2
		código
	end

<condição> ? <verdadeiro> : <falso> (pode substituir o if)
	(1 < 2) ? (puts "sim") : (puts "não")

Loops
	while a < 10
		código	
	end

	until a == 0 (até que "a" seja 0, faça)

	for a in 0..3 do(para "a" entre 0 a 3 faça)
		código
	end
	
	a.each do |b| (para cada "a" faça "b")
		código
	end


Aula 13:
Array (vetor)
	a = [1, 2, 3, "a", "b", "c"]
	
	b = Array.new
	b.push(1, "a") -> criou a array e inseriu os valores

ARGV (argument vector)
	pelo que entendi passa os valores na chamada da função

Hashes
	h = {"a" => 123, "b" => 456, 1 => "abc"}
nesse exemplo o "a" é a chave e o 123 é o valor (pensar como no vetor, a é o indici e  123 é o valor)
	h.merge!({2 => "def"}) -> adiciona a chave 2 e o valor "def" a hashe "h"

 
Aula 14:
Interpolação string -> imprime variavelconcatenando
	puts "string #{var}"
Concatenar
	string + string -> criado um novo objeto
	string << string  -> concatena no mesmo objeto (gera menos requisição)
Simbolos -> strings imutavel, um tipo objeto do Ruby (utilizadas usualmente em hashes)
	:string
	h = {a: "abc", b: 123}


Aula 15:
Metodos
array.push(valor) -> adiciona o valor como ultimo elemento do vetor
array.unshift(valor) -> adiciona o valor na primeira posição
array.pop -> remove o ultimo valor
array.shift -> remove o primeiro

criar metodo:
	def <nome>
		codigo
	end

Aula 16:
tipo definido -> VAR = "em maiusculo"
join -> array.join("colocar algo se quiser, se não junta junto :D")
eval -> interpreta uma STRING em codigo Ruby
	a = "1 + 2" (string)
	puts eval(a) #saida: 3
	b = "puts a"
	puts eval(b) #saida: 1 + 2 (imprimiu a string 'a')
instance_of?(tipo) -> compara se a entrada é uma instancia daquele tipo 
	a = 1
	a.instance_of?(String) -> False
	a.instance_of?(Fixnun) -> True
	!a.instance_of?(String) -> True (esta negando)

Aula 17:
Clases -> classe instanciada é um objeto
initialize -> inicialização da classe (@variavel)
attr_accessor :var -> cria uma variavel na classe com o metodo de leitura e escrita
	class Classe (sempre começa com maiuscula)
		attr_accessor :var
		def initialize (var)
			@var = var
		end
	end

Aula 18:
Classe e Herança -> para uma classe herdar uma outra basta usar o menor (<)
	arquivo 1:
		classe a
			cod
		end

	aquivo 2
		require_relative "arquivo 1" (chamando o "arquivo 1")
		classe b < a (herdando o que tem em "a")
			cod
		end
Aula 19:
Modulos -> Agem como Namespace, permite armazenar constantes, métodos e classe
	Module Modulo (maiuscula, assim como a Classe)
		cod
	end



































